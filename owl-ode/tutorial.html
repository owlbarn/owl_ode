<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>tutorial (owl-ode.tutorial)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">owl-ode</a> &#x00BB; tutorial</nav></header><h1 id="tutorial"><a href="#tutorial" class="anchor"></a>Tutorial</h1><p>Owl_ode is a lightweight package for solving ordinary differential equations. Built on top of Owl’s numerical library, Owl_ode was designed with extensibility and ease of use in mind and includes a number of classic ode solvers (e.g. Euler and Runge-Kutta, in both adaptive and fixed-step variants) and symplectic sovlers (e.g. Leapfrog), with more to come.</p><p>This library provides a collection of solvers for the initial value problem for ordinary differential equation systems.</p><p>You can jump to the interface of the <a href="Owl_ode/Ode/index.html#odelib"><span>Ode library</span></a>.</p><h2 id="example-of-use"><a href="#example-of-use" class="anchor"></a>Example of use</h2><p>Let's solve the linear initial value problem ∂ₜ y = A y, with y(t₀) = y₀. Say that A is the matrix ((1;-1); (2;3)), and the initial conditions are given by y(0) = (-1;1).</p><p>We begin by defining a function f(y, t) that corresponds to the RHS of the differential equation</p><pre><code class="ml">let f y t = 
let a = [|[|1.; -1.|];
            [|2.; -3.|]|]
        |&gt; Owl.Mat.of_arrays
in
Owl.Mat.(a *@ y)</code></pre><p>and the initial conditions y0</p><pre><code class="ml">let y0 = Mat.of_array [|-1.; 1.|] 2 1</code></pre><p>Before being able to actually call the integrating function, we need to define the time specification for the problem at hand</p><pre><code class="ml">let tspec = Owl_ode.Types.(T1 {t0 = 0.; duration = 2.; dt=1E-3})</code></pre><p>This in particular allows us to specify also that t₀=0. Here, we construct a record using the constructor <a href="Owl_ode/Types/index.html#type-tspec_t.T1"><code>Owl_ode.Types.tspec_t.T1</code></a>, which includes the start time t₀, the time duration for the numerical solution, and a step size dt.</p><p>Finally we can call</p><pre><code class="ml">let ts, ys = Owl_ode.odeint (module Owl_ode.Native.D.RK4) f y0 tspec () </code></pre><p>to get an array with the approximate value of the vector y at the times ts. As you can see from the snippet above, you have to specify the algorithm used for the integration by providing its module in the function call. Here, we integrated the dynamical system with <a href="Owl_ode/Native/D/RK4/index.html"><code>Owl_ode.Native.D.RK4</code></a>, a fixed-step double-precision Runge-Kutta solver. In Owl_ode, we provide a number of ocaml-based double-precision solvers in the <a href="Owl_ode/Native/D/index.html"><code>Owl_ode.Native.D</code></a> modeuoe and single-precision ones in <a href="Owl_ode/Native/S/index.html"><code>Owl_ode.Native.S</code></a>. Additional integrators are provided by external and third party libraries.</p><p>The solution can be easily plotted using <code>Owl_plplot</code> or any other owl-compatible plotting library, for example</p><pre><code class="ml">let open Owl_plplot in
let h = Plot.create &quot;myplot.png&quot; in
Plot.plot ~h ~spec:[ RGB (0,0,255); LineStyle 1 ] ts (Mat.col ys 0);
Plot.output h;</code></pre><p>You can refer to the examples in the source repository for more complex examples.</p><dl><dt>version</dt><dd>0.1</dd></dl><dl><dt>author</dt><dd>Marcello Seri and Ta-Chu Kao</dd></dl></div></body></html>