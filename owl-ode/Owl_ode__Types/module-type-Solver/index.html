<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Solver (owl-ode.Owl_ode__Types.Solver)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">owl-ode</a> &#x00BB; <a href="../index.html">Owl_ode__Types</a> &#x00BB; Solver</nav><h1>Module type <code>Owl_ode__Types.Solver</code></h1><p>Any solver compatible with <a href="../../Owl_ode/Ode/index.html#val-odeint"><code>Ode.odeint</code></a> has to comply with the Solver type. You can use this to define completely new solvers, as done in the owl-ode-sundials or ocaml-cviode libraries, or to customize pre-existing solvers (see the van_der_pol example for one such cases).</p><p>The native ocaml solvers provided by Owl_ode in both single and double precision can be found in <a href="../../Owl_ode/Native/index.html"><code>Native</code></a>, respectively in the <a href="../../Owl_ode/Native/S/index.html"><code>Native.S</code></a> and <a href="../../Owl_ode/Native/D/index.html"><code>Native.D</code></a> modules. These provide multiple single-step and adaptive implementations.</p><p>Symplectic solvers for separable Hamiltonian systems are also available and can be found in <a href="../../Owl_ode/Symplectic/S/index.html"><code>Symplectic.S</code></a> and <a href="../../Owl_ode/Symplectic/D/index.html"><code>Symplectic.D</code></a>. Refer to the damped oscillator for an example of use.</p><p>The generic solvers in <a href="../../Owl_ode/Native_generic/index.html"><code>Native_generic</code></a> and in <a href="../../Owl_ode/Symplectic_generic/index.html"><code>Symplectic_generic</code></a> can also be used in conjunction with jsoo, although how to do that is currently undocumented.</p></header><dl><dt class="spec type" id="type-state"><a href="#type-state" class="anchor"></a><code><span class="keyword">type</span> state</code></dt><dd><p><code>state</code> is the type of the state (and thus also of the initial condition) provided to <a href="../../Owl_ode/Ode/index.html#val-odeint"><code>Ode.odeint</code></a>. For example <span class="xref-unresolved" title="unresolved reference to &quot;Owl.Mat.mat&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Owl.Mat&quot;"><code>Owl</code>.Mat</span>.mat</span>.</p></dd></dl><dl><dt class="spec type" id="type-f"><a href="#type-f" class="anchor"></a><code><span class="keyword">type</span> f</code></dt><dd><p><code>f</code> is type of the evolution function. For example, in the case of sympletic solvers, <code>type state = Owl.Mat.(mat*mat)</code> and <code>type f = state -&gt; float -&gt; Owl.Mat.mat</code>.</p></dd></dl><dl><dt class="spec type" id="type-step_output"><a href="#type-step_output" class="anchor"></a><code><span class="keyword">type</span> step_output</code></dt><dd><p><code>step_output</code> defines the type of the output of <a href="../../Owl_ode/Ode/index.html#val-step"><code>Ode.step</code></a>. For example, in the case of native adaptive solvers, <code>type output = Owl.Mat.(mat * float * float * bool)</code>, corresponds to matrices and floats that contain respectively the y1, t1, dt, and whether this step was valid</p></dd></dl><dl><dt class="spec type" id="type-solve_output"><a href="#type-solve_output" class="anchor"></a><code><span class="keyword">type</span> solve_output</code></dt><dd><p><code>solve_output</code> defines the type of the output of <a href="../../Owl_ode/Ode/index.html#val-odeint"><code>Ode.odeint</code></a>. For example, in the case of sympletc solvers, <code>type output = Owl.Mat.(mat * mat * mat)</code>, corresponds to matrices that contain respectively the time, position, and momentum coordinates of the integrated solution</p></dd></dl><dl><dt class="spec value" id="val-step"><a href="#val-step" class="anchor"></a><code><span class="keyword">val</span> step : <a href="index.html#type-f">f</a> <span>&#45;&gt;</span> <span>dt:float</span> <span>&#45;&gt;</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="index.html#type-step_output">step_output</a></code></dt><dd><p><code>step f dt y0 t0 ()</code> solves for one step given dt, y0, t0 and the evolution function. Several such functions have already been implemented in this library and can be used as reference.</p></dd></dl><dl><dt class="spec value" id="val-solve"><a href="#val-solve" class="anchor"></a><code><span class="keyword">val</span> solve : <a href="index.html#type-f">f</a> <span>&#45;&gt;</span> <a href="index.html#type-state">state</a> <span>&#45;&gt;</span> <a href="../index.html#type-tspec">tspec</a> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> <a href="index.html#type-solve_output">solve_output</a></code></dt><dd><p><code>solve f y0 tspec ()</code> solves the initial value problem</p><p>∂ₜ y = f(y, t) y(t₀) = y₀</p><p>with the given evolution function f, initial condition y0, and temporal specification tspec, and returns the desired outputs of type output. Several such functions have already been implemented in this library and can be used as reference.</p></dd></dl></div></body></html>