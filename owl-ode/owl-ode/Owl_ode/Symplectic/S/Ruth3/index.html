<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ruth3 (owl-ode.Owl_ode.Symplectic.S.Ruth3)</title><link rel="stylesheet" href="../../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../../../index.html">owl-ode</a> &#x00BB; <a href="../../../index.html">Owl_ode</a> &#x00BB; <a href="../../index.html">Symplectic</a> &#x00BB; <a href="../index.html">S</a> &#x00BB; Ruth3</nav><header class="odoc-preamble"><h1>Module <code><span>S.Ruth3</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-state" class="anchored"><a href="#type-state" class="anchor"></a><code><span><span class="keyword">type</span> state</span><span> = <a href="../index.html#type-mat">mat</a> * <a href="../index.html#type-mat">mat</a></span></code></div><div class="spec-doc"><p><code>state</code> is the type of the state (and thus also of the initial condition) provided to <a href="../../../../../owl-ode-base/Owl_ode_base/Ode/index.html#val-odeint"><code>Owl_ode_base.Ode.odeint</code></a>. For example <code>Owl</code>.Mat.mat.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-f" class="anchored"><a href="#type-f" class="anchor"></a><code><span><span class="keyword">type</span> f</span><span> = <span><span>(<a href="../index.html#type-mat">mat</a> * <a href="../index.html#type-mat">mat</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <a href="../index.html#type-mat">mat</a></span></code></div><div class="spec-doc"><p><code>f</code> is type of the evolution function. For example, in the case of sympletic solvers, <code>type state = Owl.Mat.(mat*mat)</code> and <code>type f = state -&gt; float -&gt; Owl.Mat.mat</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-step_output" class="anchored"><a href="#type-step_output" class="anchor"></a><code><span><span class="keyword">type</span> step_output</span><span> = <span>(<a href="../index.html#type-mat">mat</a> * <a href="../index.html#type-mat">mat</a>)</span> * float</span></code></div><div class="spec-doc"><p><code>step_output</code> defines the type of the output of <a href="../../../Ode/index.html#val-step"><code>Owl_ode.Ode.step</code></a>. For example, in the case of native adaptive solvers, <code>type output = Owl.Mat.(mat * float * float * bool)</code>, corresponds to matrices and floats that contain respectively the y1, t1, dt, and whether this step was valid</p></div></div><div class="odoc-spec"><div class="spec type" id="type-solve_output" class="anchored"><a href="#type-solve_output" class="anchor"></a><code><span><span class="keyword">type</span> solve_output</span><span> = <a href="../index.html#type-mat">mat</a> * <a href="../index.html#type-mat">mat</a> * <a href="../index.html#type-mat">mat</a></span></code></div><div class="spec-doc"><p><code>solve_output</code> defines the type of the output of <a href="../../../Ode/index.html#val-odeint"><code>Owl_ode.Ode.odeint</code></a>. For example, in the case of sympletc solvers, <code>type output = Owl.Mat.(mat * mat * mat)</code>, corresponds to matrices that contain respectively the time, position, and momentum coordinates of the integrated solution</p></div></div><div class="odoc-spec"><div class="spec value" id="val-step" class="anchored"><a href="#val-step" class="anchor"></a><code><span><span class="keyword">val</span> step : <span><a href="#type-f">f</a> <span class="arrow">&#45;&gt;</span></span> <span>dt:float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <a href="#type-step_output">step_output</a></span></code></div><div class="spec-doc"><p><code>step f dt y0 t0 ()</code> solves for one step given dt, y0, t0 and the evolution function. Several such functions have already been implemented in this library and can be used as reference.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-solve" class="anchored"><a href="#val-solve" class="anchor"></a><code><span><span class="keyword">val</span> solve : <span><a href="#type-f">f</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-state">state</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../../../owl-ode-base/Owl_ode_base/Types/index.html#type-tspec">Types.tspec</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-solve_output">solve_output</a></span></code></div><div class="spec-doc"><p><code>solve f y0 tspec ()</code> solves the initial value problem</p><p>∂ₜ y = f(y, t) y(t₀) = y₀</p><p>with the given evolution function f, initial condition y0, and temporal specification tspec, and returns the desired outputs of type output. Several such functions have already been implemented in this library and can be used as reference.</p></div></div></div></body></html>